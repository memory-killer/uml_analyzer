"""
clang-uml JSON parser

Parses JSON files generated by clang-uml into Python objects.
"""

import json
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field


@dataclass
class ClassElement:
    """Data class representing a class/interface element."""
    id: str
    name: str
    namespace: str
    display_name: str
    type: str  # class, struct, interface, etc.
    is_abstract: bool = False
    is_template: bool = False
    members: List[Dict[str, Any]] = field(default_factory=list)
    methods: List[Dict[str, Any]] = field(default_factory=list)
    bases: List[Dict[str, Any]] = field(default_factory=list)
    source_location: Optional[Dict[str, Any]] = None
    
    @property
    def full_name(self) -> str:
        """Full name including namespace."""
        return f"{self.namespace}::{self.name}" if self.namespace else self.name
    
    @property
    def member_count(self) -> int:
        """Number of member variables."""
        return len(self.members)
    
    @property
    def method_count(self) -> int:
        """Number of methods."""
        return len(self.methods)
    
    @property
    def complexity_score(self) -> int:
        """Complexity score (members + methods + base classes)."""
        return self.member_count + self.method_count + len(self.bases)


@dataclass
class Relationship:
    """Data class representing a relationship between classes."""
    source: str
    destination: str
    type: str  # extension, association, dependency, aggregation, composition
    label: Optional[str] = None
    access: Optional[str] = None  # public, private, protected
    
    def __repr__(self) -> str:
        label_str = f" [{self.label}]" if self.label else ""
        return f"{self.source} --{self.type}{label_str}--> {self.destination}"


@dataclass
class DiagramData:
    """Container for all class diagram data."""
    name: str
    diagram_type: str
    elements: Dict[str, ClassElement]
    relationships: List[Relationship]
    metadata: Dict[str, Any]
    package_type: Optional[str] = None
    using_namespace: Optional[str] = None
    
    @property
    def element_count(self) -> int:
        return len(self.elements)
    
    @property
    def relationship_count(self) -> int:
        return len(self.relationships)
    
    def get_element_by_name(self, name: str) -> Optional[ClassElement]:
        """Find an element by name."""
        for elem in self.elements.values():
            if elem.name == name or elem.full_name == name:
                return elem
        return None
    
    def get_namespaces(self) -> List[str]:
        """Return a sorted list of all unique namespaces."""
        namespaces = set()
        for elem in self.elements.values():
            if elem.namespace:
                # Handle hierarchical namespaces (e.g. app::core::detail)
                parts = elem.namespace.split("::")
                for i in range(1, len(parts) + 1):
                    namespaces.add("::".join(parts[:i]))
        return sorted(namespaces)


class ClangUMLParser:
    """Parser for clang-uml class diagram JSON."""
    
    def __init__(self):
        self.data: Optional[DiagramData] = None
    
    def parse_file(self, filepath: Path) -> DiagramData:
        """Parse a JSON file into diagram data."""
        with open(filepath, 'r', encoding='utf-8') as f:
            raw_data = json.load(f)
        
        return self.parse_dict(raw_data, filepath.stem)
    
    def parse_dict(self, raw_data: Dict[str, Any], name: str = "diagram") -> DiagramData:
        """Parse a raw dictionary into diagram data."""
        # Parse elements
        elements = {}
        for elem_data in raw_data.get("elements", []):
            elem = self._parse_element(elem_data)
            elements[elem.id] = elem
        
        # Parse relationships
        relationships = []
        for rel_data in raw_data.get("relationships", []):
            rel = self._parse_relationship(rel_data)
            relationships.append(rel)
        
        # Create diagram data object
        self.data = DiagramData(
            name=name,
            diagram_type=raw_data.get("diagram_type", "class"),
            elements=elements,
            relationships=relationships,
            metadata=raw_data.get("metadata", {}),
            package_type=raw_data.get("package_type"),
            using_namespace=raw_data.get("using_namespace")
        )
        
        return self.data
    
    def _parse_element(self, elem_data: Dict[str, Any]) -> ClassElement:
        """Parse a single element node."""
        return ClassElement(
            id=elem_data["id"],
            name=elem_data["name"],
            namespace=elem_data.get("namespace", ""),
            display_name=elem_data.get("display_name", elem_data["name"]),
            type=elem_data.get("type", "class"),
            is_abstract=elem_data.get("is_abstract", False),
            is_template=elem_data.get("is_template", False),
            members=elem_data.get("members", []),
            methods=elem_data.get("methods", []),
            bases=elem_data.get("bases", []),
            source_location=elem_data.get("source_location")
        )
    
    def _parse_relationship(self, rel_data: Dict[str, Any]) -> Relationship:
        """Parse a single relationship."""
        return Relationship(
            source=rel_data["source"],
            destination=rel_data["destination"],
            type=rel_data["type"],
            label=rel_data.get("label"),
            access=rel_data.get("access")
        )
    
    def get_statistics(self) -> Dict[str, Any]:
        """Return statistics about the parsed class diagram."""
        if not self.data:
            return {}
        
        return {
            "diagram_name": self.data.name,
            "diagram_type": self.data.diagram_type,
            "total_elements": self.data.element_count,
            "total_relationships": self.data.relationship_count,
            "namespaces": self.data.get_namespaces(),
            "namespace_count": len(self.data.get_namespaces()),
            "clang_uml_version": self.data.metadata.get("clang_uml_version"),
            "llvm_version": self.data.metadata.get("llvm_version"),
        }


if __name__ == "__main__":
    # Simple manual test
    parser = ClangUMLParser()
    test_file = Path("test_project/output/app_class_diagram.json")
    
    if test_file.exists():
        data = parser.parse_file(test_file)
        print(f"âœ… Parsed successfully: {data.element_count} elements, {data.relationship_count} relationships")
        print(f"Namespaces: {data.get_namespaces()}")
        
        stats = parser.get_statistics()
        print(f"\nStatistics:")
        for key, value in stats.items():
            if key != "namespaces":
                print(f"  {key}: {value}")

