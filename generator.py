"""
PlantUML generator.

Generate small .puml files from filtered node sets.
"""

import networkx as nx
from typing import Set, Dict, List, Optional
from pathlib import Path

from .parser import DiagramData, ClassElement, Relationship
from .graph_builder import GraphBuilder


class PumlGenerator:
    """PlantUML class diagram generator."""
    
    def __init__(
        self,
        diagram_data: DiagramData,
        graph_builder: GraphBuilder
    ):
        self.data = diagram_data
        self.builder = graph_builder
    
    def generate_puml(
        self,
        node_ids: Set[str],
        title: Optional[str] = None,
        show_members: bool = True,
        show_methods: bool = True,
        group_by_namespace: bool = True
    ) -> str:
        """
        Generate PlantUML code for the given node set.
        
        Args:
            node_ids: Set of node IDs to include.
            title: Diagram title.
            show_members: Whether to show member variables.
            show_methods: Whether to show methods.
            group_by_namespace: Whether to group by namespace.
        """
        lines = ["@startuml"]
        
        if title:
            lines.append(f"title {title}")
        
        lines.append("")
        
        # Group nodes by namespace
        if group_by_namespace:
            namespace_groups = self._group_by_namespace(node_ids)
            for namespace, nodes in sorted(namespace_groups.items()):
                if namespace:
                    lines.append(f"namespace {namespace} {{")
                    lines.append("")
                
                for node_id in nodes:
                    lines.extend(self._generate_class_definition(
                        node_id, show_members, show_methods, indent=2 if namespace else 0
                    ))
                
                if namespace:
                    lines.append("}")
                    lines.append("")
        else:
            for node_id in node_ids:
                lines.extend(self._generate_class_definition(
                    node_id, show_members, show_methods
                ))
        
        # Add relationships (only between filtered nodes)
        lines.append("' Relationships")
        for rel in self.data.relationships:
            if rel.source in node_ids and rel.destination in node_ids:
                lines.append(self._generate_relationship(rel))
        
        lines.append("")
        lines.append(f"'Generated by uml_processor")
        lines.append("@enduml")
        
        return "\n".join(lines)
    
    def _group_by_namespace(self, node_ids: Set[str]) -> Dict[str, List[str]]:
        """Group node IDs by (top-level) namespace."""
        groups = {}
        
        for node_id in node_ids:
            attrs = self.builder.get_node_attributes(node_id)
            namespace = attrs.get("namespace", "")
            
            # Use only top-level namespace (e.g. app::core::detail -> app::core)
            if namespace:
                parts = namespace.split("::")
                top_namespace = "::".join(parts[:2]) if len(parts) > 1 else parts[0]
            else:
                top_namespace = ""
            
            if top_namespace not in groups:
                groups[top_namespace] = []
            groups[top_namespace].append(node_id)
        
        return groups
    
    def _generate_class_definition(
        self,
        node_id: str,
        show_members: bool,
        show_methods: bool,
        indent: int = 0
    ) -> List[str]:
        """Generate PlantUML class definition lines for a node."""
        attrs = self.builder.get_node_attributes(node_id)
        element: ClassElement = attrs.get("element")
        
        if not element:
            return []
        
        lines = []
        indent_str = " " * indent
        
        # Class type (abstract, interface, etc.)
        class_type = "abstract" if element.is_abstract else "class"
        alias = self._get_alias(node_id)
        
        # Class declaration
        lines.append(f'{indent_str}{class_type} "{element.name}" as {alias} {{')
        
        # Methods
        if show_methods and element.methods:
            for method in element.methods:
                access = self._get_access_symbol(method.get("access", "public"))
                name = method.get("name", "")
                return_type = method.get("type", "void")
                
                # Parameters
                params = method.get("parameters", [])
                param_str = ", ".join(
                    f"{p.get('type', '')} {p.get('name', '')}"
                    for p in params
                )
                
                is_abstract = method.get("is_pure_virtual", False)
                abstract_suffix = " = 0" if is_abstract else ""
                
                lines.append(
                    f"{indent_str}  {access}{name}({param_str}) : {return_type}{abstract_suffix}"
                )
            
            if show_members and element.members:
                lines.append(f"{indent_str}  ..")
        
        # Members
        if show_members and element.members:
            for member in element.members:
                access = self._get_access_symbol(member.get("access", "private"))
                name = member.get("name", "")
                type_name = member.get("type", "")
                lines.append(f"{indent_str}  {access}{name} : {type_name}")
        
        lines.append(f"{indent_str}}}")
        lines.append("")
        
        return lines
    
    def _generate_relationship(self, rel: Relationship) -> str:
        """Generate a PlantUML relationship line."""
        source_alias = self._get_alias(rel.source)
        dest_alias = self._get_alias(rel.destination)
        
        # PlantUML arrow per relationship type
        arrow_map = {
            "extension": "<|--",          # inheritance
            "composition": "*--",         # composition
            "aggregation": "o--",         # aggregation
            "association": "-->",         # association
            "dependency": "..>",          # dependency
        }
        
        arrow = arrow_map.get(rel.type, "-->")
        label = f' : "{rel.label}"' if rel.label else ""
        
        return f"{dest_alias} {arrow} {source_alias}{label}"
    
    def _get_alias(self, node_id: str) -> str:
        """Convert node ID into a PlantUML alias."""
        return f"C_{node_id[:16]}"
    
    def _get_access_symbol(self, access: str) -> str:
        """Return UML access symbol for a visibility string."""
        symbols = {
            "public": "+",
            "private": "-",
            "protected": "#",
        }
        return symbols.get(access, "+")
    
    def save_puml(
        self,
        node_ids: Set[str],
        output_path: Path,
        title: Optional[str] = None,
        **kwargs
    ):
        """Save PlantUML code to a file."""
        puml_content = self.generate_puml(node_ids, title, **kwargs)
        
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(puml_content, encoding='utf-8')
    
    def generate_multiple_views(
        self,
        views: Dict[str, Set[str]],
        output_dir: Path,
        **kwargs
    ) -> List[Path]:
        """
        Generate PUML files for multiple views.
        
        Returns:
            List of generated file paths.
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        generated_files = []
        
        for view_name, node_ids in views.items():
            if not node_ids:
                continue
            
            output_file = output_dir / f"{view_name}.puml"
            title = f"{self.data.name} - {view_name}"
            
            self.save_puml(node_ids, output_file, title, **kwargs)
            generated_files.append(output_file)
        
        return generated_files
    
    def generate_index_html(
        self,
        views: Dict[str, Set[str]],
        output_dir: Path,
        svg_dir: Optional[Path] = None
    ) -> Path:
        """
        Generate an HTML index page listing all views.
        
        Args:
            views: Mapping of view name to node IDs.
            output_dir: Output directory for PUML files.
            svg_dir: Directory that contains SVG files (output_dir if None).
        """
        if svg_dir is None:
            svg_dir = output_dir
        
        html_lines = [
            "<!DOCTYPE html>",
            "<html lang='en'>",
            "<head>",
            "  <meta charset='UTF-8'>",
            "  <meta name='viewport' content='width=device-width, initial-scale=1.0'>",
            f"  <title>{self.data.name} - UML Diagrams</title>",
            "  <style>",
            "    body { font-family: 'Segoe UI', sans-serif; margin: 20px; background: #f5f5f5; }",
            "    h1 { color: #333; }",
            "    .view-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; }",
            "    .view-card { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }",
            "    .view-card h2 { margin-top: 0; color: #0066cc; }",
            "    .view-card p { color: #666; }",
            "    .view-card a { display: inline-block; margin-top: 10px; padding: 8px 16px; background: #0066cc; color: white; text-decoration: none; border-radius: 4px; }",
            "    .view-card a:hover { background: #0052a3; }",
            "    .stats { background: #e8f4f8; padding: 10px; border-radius: 4px; margin-top: 10px; }",
            "  </style>",
            "</head>",
            "<body>",
            f"  <h1>{self.data.name} - UML Diagram Views</h1>",
            f"  <p>{len(views)} views generated</p>",
            "  <div class='view-grid'>",
        ]
        
        for view_name, node_ids in sorted(views.items()):
            node_count = len(node_ids)
            svg_file = svg_dir / f"{view_name}.svg"
            puml_file = output_dir / f"{view_name}.puml"
            
            # Check whether SVG/PUML files exist
            has_svg = svg_file.exists()
            has_puml = puml_file.exists()
            
            html_lines.extend([
                "    <div class='view-card'>",
                f"      <h2>{view_name}</h2>",
                f"      <div class='stats'>",
                f"        <p><strong>Nodes:</strong> {node_count}</p>",
                f"      </div>",
            ])
            
            # Add links (prefer SVG, fall back to PUML)
            if has_svg:
                html_lines.append(f"      <a href='{svg_file.name}' target='_blank'>View Diagram (SVG)</a>")
            if has_puml:
                link_text = "View PlantUML" if has_svg else "View PlantUML (SVG not generated)"
                html_lines.append(f"      <a href='{puml_file.name}' target='_blank' style='margin-left: 10px; background: #666;'>{link_text}</a>")
            if not has_svg and not has_puml:
                html_lines.append("      <p style='color: #999;'>No diagram available</p>")
            
            html_lines.append("    </div>")
        
        html_lines.extend([
            "  </div>",
            "</body>",
            "</html>",
        ])
        
        index_file = output_dir / "index.html"
        index_file.write_text("\n".join(html_lines), encoding='utf-8')
        
        return index_file


if __name__ == "__main__":
    # Simple manual test
    from pathlib import Path
    from .parser import ClangUMLParser
    from .analyzer import GraphAnalyzer
    from .filter import DiagramFilter
    
    parser = ClangUMLParser()
    test_file = Path("test_project/output/app_class_diagram.json")
    
    if test_file.exists():
        data = parser.parse_file(test_file)
        builder = GraphBuilder(data)
        analyzer = GraphAnalyzer(builder.get_graph())
        filter_obj = DiagramFilter(data, builder, analyzer)
        generator = PumlGenerator(data, builder)
        
        # Create namespace-based views
        views = filter_obj.create_namespace_views()
        
        output_dir = Path("test_project/output/views")
        files = generator.generate_multiple_views(views, output_dir)
        
        print(f"âœ… Generated {len(files)} PUML files:")
        for f in files:
            print(f"  - {f}")

